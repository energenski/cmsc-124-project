import sys
import re
from lexer import lexer, Token

VAR_NAME_REGEX = re.compile(r"^[A-Za-z][A-Za-z0-9_]*$")

#CURRENT CAPABILITIES
# 1. Program structure; checks for HAI and KTHXBYE
# 2. Variable declaration; identifies WAZZUP and checks for BUHBYE
# 3. Recognizes I HAS A followed by an IDENTIFIER, and optionally, initialization with ITZ
# 4. Assignment; IDENTIFIER followed by R
# 5. I/0; recognizes GIMMEH followed by an IDENTIFIER
# 6. recognizes VISIBLE
# 7. If-then; parses the basic if-then-else structure using O RLY?, YA RLY, an optional NO WAI, and the closing OIC
# 8. Loops; parses the full loop structure, including the start (IM IN YR <label>) and end (IM OUTTA YR <label>) , 
#     the operation (UPPIN or NERFIN) on a variable (YR <variable>) , and the termination condition (TIL or WILE)
# 9. Function definition; recognizes the start of a function definition (HOW IZ I <function name>) and the end (IF U SAY SO).
# 10. Error handling; basic mechanisms to record errors for expected keywords and tokens
# 11. Comment skipping; implements a function to skip BTW comments

#NOT YET IMPLEMENTED
# 1. Switch-case (WTF, OMG, OMGWTF, OIC)
# 2. Loop break (GTFO)
# 3. Function call (I IZ, MKAY)
# 4. Function Return (FOUND YR)
# 5. Type Casting	(MAEK, IS NOW A)
# 6. Multi-line Comments (OBTW, TLDR)
# 7. Else-If (MEBBE)
# 8. skip expression function doesn't perform analysis on the expression yet

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens    #generated by lexer
        self.position = 0       #index of current token processed
        self.errors = []        #store the syntax errors found
        self.variables_declared = set() #track declared variable identifiers
        self.in_wazzup = False  #whether the parser is inside the wazzup block

    #return token at current position
    def current(self):
        return self.tokens[self.position] if self.position < len(self.tokens) else Token("EOF", "", -1, -1)

    #consume current token if it matches expected type
    def eat(self, token_type):
        if self.current().type == token_type:
            self.position += 1
        else:
            self.record_error(f"Expected {token_type}, got {self.current().type}", self.current())
            self.position += 1

    #append to error list if error is encountered in a line
    def record_error(self, message, token):
        self.errors.append(f"Line {token.line}: {message} (token: '{token.value}')")

    #initializes comment skipping, runs the top-level program rule, and checks that the stream ends with EOF
    def parse(self):
        self.skip_comments()
        self.program()
        if self.current().type != "EOF":
            self.record_error("Unexpected tokens after program end", self.current())

    #checks for the program structure HAI ... KTHXBYE
    def program(self):
        if self.current().type != "HAI":
            self.record_error("Program must start with HAI", self.current())
        else:
            self.eat("HAI")

        if self.current().type == "WAZZUP":
            self.in_wazzup = True
            self.eat("WAZZUP")
            while self.current().type != "BUHBYE" and self.current().type != "EOF":
                self.statement()
            if self.current().type != "BUHBYE":
                self.record_error("Missing BUHBYE after WAZZUP", self.current())
            else:
                self.eat("BUHBYE")
            self.in_wazzup = False

        while self.current().type != "KTHXBYE" and self.current().type != "EOF":
            self.statement()

        if self.current().type != "KTHXBYE":
            self.record_error("Program must end with KTHXBYE", self.current())
        else:
            self.eat("KTHXBYE")

    #look at the very first token of a line of code and figure out what kind of instruction it is
    #then branches it out to its designated function
    def statement(self):
        tok = self.current().type
        if tok == "I_HAS_A":
            self.var_declaration()
        elif tok == "IDENTIFIER" and self.peek().type == "R":
            self.assignment()
        elif tok == "VISIBLE":
            self.output_statement()
        elif tok == "GIMMEH":
            self.input_statement()
        elif tok == "ORLY":
            self.if_statement()
        elif tok == "WTF":
            self.switch_statement
        elif tok == "IM_IN_YR":
            self.loop_statement()
        elif tok == "HOW":
            self.function_def()
        else:
            self.record_error(f"Unexpected token {tok}", self.current())
            self.position += 1

    #parses I HAS A <var> optionally followed by ITZ and an expression
    #records the variable name in variables_declared
    #performs a basic regex check on the identifier
    #still incomplete
    def var_declaration(self):
        self.eat("I_HAS_A")
        if self.current().type != "IDENTIFIER" or not VAR_NAME_REGEX.match(self.current().value):
            self.record_error("Invalid variable name in declaration", self.current())
        else:
            self.variables_declared.add(self.current().value)
            self.eat("IDENTIFIER")
        if self.current().type == "ITZ":
            self.eat("ITZ")
            self.skip_expression()

    #parses <var> R <expression>
    #still cant validate expression
    #can't handle typecasting yet
    def assignment(self):
        self.eat("IDENTIFIER")
        self.eat("R")
        self.skip_expression()

    #parses gimmeh
    #does not check if the identifier following GIMMEH is a declared variable
    def input_statement(self):
        self.eat("GIMMEH")
        if self.current().type != "IDENTIFIER":
            self.record_error("GIMMEH must be followed by variable", self.current())
        else:
            self.eat("IDENTIFIER")

    #this method stops prematurely if an AN is found inside a nested expression since
    #it can't validate the expression after an yet
    def output_statement(self):
        self.eat("VISIBLE")
        self.skip_expression()
        while self.current().type == "AN":
            self.eat("AN")
            self.skip_expression()

    #parses the o rly structure
    #does not support expression before O rly
    #does not support MEBBE
    def if_statement(self):
        # --- Step 1: The condition before O RLY? is usually an expression that sets IT ---
        condition_node = self.previous()  # or parse expression just before O RLY?

        self.eat("ORLY")  # Consume O RLY?

        # --- Step 2: Parse YA RLY block ---
        if self.current().type != "YA_RLY":
            self.record_error("Missing YA_RLY after ORLY", self.current())
            true_block = []
        else:
            self.eat("YA_RLY")
            true_block = []
            while self.current().type not in ("MEBBE", "NO_WAI", "OIC", "EOF"):
                true_block.append(self.statement())

        # --- Step 3: Parse zero or more MEBBE (else-if) blocks ---
        elif_blocks = []
        while self.current().type == "MEBBE":
            self.eat("MEBBE")
            # MEBBE is followed by its condition expression on the same line
            mebbe_condition = self.parse_expression()
            mebbe_body = []
            while self.current().type not in ("MEBBE", "NO_WAI", "OIC", "EOF"):
                mebbe_body.append(self.statement())
            elif_blocks.append({
                'condition': mebbe_condition,
                'body': mebbe_body
            })

        # --- Step 4: Parse optional NO WAI block ---
        else_block = []
        if self.current().type == "NO_WAI":
            self.eat("NO_WAI")
            while self.current().type not in ("OIC", "EOF"):
                else_block.append(self.statement())

        # --- Step 5: Eat OIC ---
        if self.current().type != "OIC":
            self.record_error("Missing OIC at end of IF block", self.current())
        else:
            self.eat("OIC")

        # --- Step 6: Return AST node ---
        return {
            'node_type': 'if_stmt',
            'condition': condition_node,
            'true_block': true_block,
            'else_if_blocks': elif_blocks,
            'else_block': else_block
        }

    #parses switch-case structure
    def switch_statement(self):
        self.eat("WTF")  # Consume WTF?

        # Step 1: Parse the switch expression (e.g., X)
        if self.current().type in ("OMG", "OMGWTF", "EOF"):
            self.record_error("Expected expression after WTF?", self.current())
            switch_expr = None
        else:
            # Parse the expression that will be compared to OMG cases
            switch_expr = self.parse_expression()

        cases = []
        default_case = []

        # Step 2: Parse OMG / OMGWTF blocks
        while self.current().type not in ("OIC", "EOF"):
            if self.current().type == "OMG":
                self.eat("OMG")
                # Each OMG must have a literal/expression for comparison
                if self.current().type not in ("IDENTIFIER", "INTEGER_LITERAL", "FLOAT_LITERAL", "STRING", "TROOF_LITERAL"):
                    self.record_error("Expected literal after OMG", self.current())
                    case_expr = None
                else:
                    case_expr = self.parse_expression()
                body = []
                while self.current().type not in ("OMG", "OMGWTF", "OIC", "EOF"):
                    body.append(self.statement())
                cases.append({'value': case_expr, 'body': body})
            elif self.current().type == "OMGWTF":
                self.eat("OMGWTF")
                while self.current().type not in ("OIC", "EOF"):
                    default_case.append(self.statement())
            else:
                self.record_error(f"Unexpected token in switch: {self.current().type}", self.current())
                self.position += 1

        # Step 3: Ensure OIC ends the switch
        if self.current().type != "OIC":
            self.record_error("Missing OIC at end of switch", self.current())
        else:
            self.eat("OIC")

        # Return AST node
        return {
            'node_type': 'switch_stmt',
            'switch_expr': switch_expr,  # store the identifier/value to compare
            'cases': cases,
            'default': default_case
        }


    #parses loop syntax
    #can't validate variables and can't handle nested loops
    def loop_statement(self):
        self.eat("IM_IN_YR")
        if self.current().type == "IDENTIFIER":
            self.eat("IDENTIFIER")
        if self.current().type in ("UPPIN", "NERFIN"):
            self.eat(self.current().type)
            if self.current().type == "YR":
                self.eat("YR")
                self.eat("IDENTIFIER")
        if self.current().type in ("TIL", "WILE"):
            self.eat(self.current().type)
            self.skip_expression()
        while self.current().type not in ("IM_OUTTA_YR", "EOF"):
            self.statement()
        if self.current().type != "IM_OUTTA_YR":
            self.record_error("Missing IM_OUTTA_YR at end of loop", self.current())
        else:
            self.eat("IM_OUTTA_YR")
            if self.current().type == "IDENTIFIER":
                self.eat("IDENTIFIER")

    #parses function definition
    #bypass parsing the function parameters and the function body.
    def function_def(self):
        self.eat("HOW")
        self.eat("IZ")
        self.eat("I")
        if self.current().type != "IDENTIFIER":
            self.record_error("Invalid function name", self.current())
        else:
            self.eat("IDENTIFIER")
        while self.current().type not in ("IF_U_SAY_SO", "EOF"):
            self.position += 1
        if self.current().type == "IF_U_SAY_SO":
            self.eat("IF_U_SAY_SO")

    #advance the parser over a sequence of tokens allowing the structural methods to function without a complete expression parser
    #stops prematurely on required expression components
    def skip_expression(self):
        while self.current().type not in ("EOF", "AN", "BTW", "VISIBLE", "GIMMEH",
                                         "I_HAS_A", "R", "ORLY", "IM_IN_YR",
                                         "HOW", "OIC", "NO_WAI"):
            self.position += 1

    #returns next token
    def peek(self):
        if self.position + 1 < len(self.tokens):
            return self.tokens[self.position + 1]
        return Token("EOF", "", -1, -1)

    #skip oneline comments
    def skip_comments(self):
        while self.current().type == "BTW":
            self.position += 1

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python parser.py <lolcode_file.lol>", file=sys.stderr)
        sys.exit(2)

    path = sys.argv[1]
    try:
        with open(path, "r", encoding="utf-8") as f:
            code = f.read()
    except Exception as e:
        print(f"Error reading {path}: {e}", file=sys.stderr)
        sys.exit(1)

    tokens = lexer(code)
    parser = Parser(tokens)
    parser.parse()

    if parser.errors:
        print("\n--- ERRORS DETECTED ---")
        for err in parser.errors:
            print(err)
        print(f"Total errors: {len(parser.errors)}")
    else:
        print("No errors found.")

# References:
# - https://ruslanspivak.com/lsbasi-part7/
# - https://github.com/Vipul97/proglang/blob/master/proglang/parser.py
# - https://github.com/dshongphuc/lexical-parser/blob/master/parser.py
